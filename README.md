# JAEBIN KIM (202038112)
### Motto : STICK IT OUT

#### 자바 형태 (기본)
```JAVA
public class 클래스명 {
    public static void main(String[] args) {
        실행할 문장;
    }
}
```
# 19/04/2024 (7week)


# 12/04/2024 (6week)
# 제어자
## 접근 제어자
### public 접근 제어자
    외부 클래스가 자유롭게 사용할 수 있도록 한다.
### protected 접근 제어자
    같은 패키지 또는 자식 클래스에서 사용할 수 있도록 한다.
### private 접근 제어자
    개인적인 것이라 외부에서 사용될 수 없도록 한다.
위 세 가지 접근 제한자가 적용되지 않으면 default 접근 제한을 가진다.
### default 접근 제어자
    같은 패키지에 소속된 클래스에서만 사용할 수 있도록 한다.
|접근 제한|적용 대상|접근할 수 없는 클래스|
|-----|----------------------|-------------------|
|public|클래스, 필드, 생성자, 메소드|없음|
|protected|필드, 생성자, 메소드|자식 클래스가 아닌 다른 패키지에 소속된 클래스|
|default|클래스, 필드, 생성자, 메소드|다른 패키지에 소속된 클래스|
|private|필드, 생성자, 메소드|모든 외부 클래스|

![자바 접근 제어자](https://hongong.hanbit.co.kr/wp-content/uploads/2021/09/01-%EC%9E%90%EB%B0%94%EC%9D%98-%EC%A0%91%EA%B7%BC-%EC%A0%9C%ED%95%9C%EC%9E%90_public_private.png)

## 기타 제어자
### final 제어자
    '변경할 수 없다'는 의미로 사용된다.      //클래스, 메소드, 필드, 지역 변수
- 필드나 지역 변수에 사용하면 값을 변경할 수 없는 상수가 된다.
- 클래스는 다른 클래스가 상속받을 수 없게 된다.
- 메소드는 오버라이딩을 통한 재정의를 할 수 없게 된다.

### static 제어자
    '공통적인'이라는 의미로 사용된다.        //메소드, 필드, 초기화 블록
- 해당 변수를 클래스 변수로 만들어 준다.
- 해당 메소드를 클래스 메소드로 만들어 준다.
- 초기화 블록에도 사용할 수 있다.

### abstract 제어자
    '추상적인'이라는 의미로 사용된다.       //클래스, 메소드
- 추상 메소드
    - 선언부만 있고 구현부가 없는 메소드
- 추상 클래스
    - 하나 이상의 추상 메소드를 포함하고 있는 클래스
주의! 반드시, ***abstract*** 제어자로!


# 05/04/2024 (5week)
# 6. 클래스
## 26) 클래스의 개념
### 객체 지향 프로그래밍(OOP, Object-Oriented Programming)
    객체의 상태(state)와 행동(behavior)을 구체화하는 형태의 프로그래밍
객체 지향 프로그래밍에서는 모든 데이터를 객체(object)로 취급하며 이러한 객체가 바로 프로그래밍의 중심이 된다.

### 클래스(Class)란?
- Java에서 객체를 생성하기 위한 일종의 설계도이다.
    - 흔히 붕어빵(객체)를 만들기 위한 붕어빵 틀(클래스)이라고 비유를 한다.
- 객체가 가지는 속성(필드)와 동작(메서드)으로 이루어져 있다.
    - 이들은 생략될 수도 있고 하나 이상 작성될 수도 있다.
- Java를 실행 시 클래스는 JVM 메모리의 클래스 영역(Class Area)에 로드된다.
### 객체(Object)란?
- 물리적으로 존재하거나 추상적으로 생각할 수 있는 것 중에서
    - 자신의 속성을 가지고 있고, 다른 것과 식별 가능한 것을 말한다.
### 인스턴스(Instance)란?
- 클래스가 붕어빵 틀이라면, 그 틀을 통해 생성된 객체 하나하나를 해당 클래스의 인스턴스라 한다.
- 클래스를 사용하여 힙 영역(Heap Area)에 새로운 인스턴스(객체)를 생성할 수 있다.
    - 즉, 인스턴스란? 현실의 객체를 소프트웨어 내에서 구현한 실체라고 볼 수 있다.
### 요약
- 객체(Object)란 자신 고유의 속성을 가지는 물리적, 추상적인 모든 대상을 일컫는다.
- 클래스(Class)란 객체들을 소프트웨어 내에서 구현하기 위해 만든 설계도이다.
    - 이를 통해 생성된 객체 하나하나를 인스턴스(Instance)라고 부른다.
    - 대체로 객체와 인스턴스는 혼용해서 표현한다.

## 27) 클래스의 구성
### 클래스의 구성 요소
클래스는 멤버(member)로 **속성을 표현하는 필드(field)**와 **기능을 표현하는 메소드(method)**를 가진다.<br>
또한, 클래스는 **생성된 객체의 필드를 초기화해주는 특별한 메소드인 생성자(constructor)**를 가진다.

### 필드(field)
    클래스에 포함된 변수(variable)를 의미한다.
1. 클래스 변수(static variable)
2. 인스턴스 변수(instance variable)
3. 지역 변수(local variable)

### 메소드(method)
    어떠한 특정 작업을 수행하기 위한 명령문의 집합이라 할 수 있다.
- 메소드를 사용하면 **중복되는 코드의 반복적인 프로그래밍을 피할 수 있다.**
- 모듈화로 인해 **전체적인 코드의 가독성이 좋아진다.**
- 프로그램에 문제가 발생하거나 기능의 변경이 필요할 때도 **손쉽게 유지보수를 할 수 있다.**

### 생성자(constructor)
    객체의 생성과 동시에 인스턴스 변수를 원하는 값으로 초기화할 수 있는 생성자라는 메소드라 할 수 있다.
- 클래스를 가지고 객체를 생성하면 해당 객체는 메모리에 즉시 생성된다.
- 주의! 생성자의 이름은 해당 클래스의 이름과 같아야 한다.


### 생성자(constructor)

# 29/03/2024 (4week)
# 5. 배열
## 22) 메모리 구조
### 메모리 구조
- 모든 자바 프로그램은 자바 가상 머신(JVM)을 통해서 실행된다.
- 자바 프로그램이 실행되면 JVM은 운영 체제로부터 해당 프로그램을 수행할 수 있도록 필요한 메모리를 할당받는다.<br>
![메모리 구조](https://www.tcpschool.com/lectures/img_java_memory_structure.png)<br>

### 메소드(method) 영역
    자바 프로그램에서 사용되는 클래스에 대한 정보와 함께 클래스 변수(static variable)가 저장되는 영역이다.

- JVM은 자바 프로그램에서 특정 클래스가 사용되면 해당 클래스의 클래스 파일(*.class)를 읽어들여, 해당 클래스에 대한 정보를 메소드 영역에 저장한다.

### 힙(heap) 영역
    자바 프로그램에서 사용되는 모든 인스턴스 변수가 저장되는 영역이다.

- JVM은 자바 프로그램에서 new키워드를 사용하여 인스턴스가 생성되면, 해당 인스턴스의 정보를 힙 영역에 저장한다.

- 힙 영역은 메모리의 낮은 주소에서 높은 주소의 방향으로 할당된다.

### 스택(stack) 영역
    자바 프로그램에서 메소드가 호출될 때 메소드의 스택 프레임이 저장되는 영역이다.

- JVM은 자바 프로그램에서 메소드가 호출되면 메소드의 호출과 관계되는 지역 변수와 매개변수를 스택 영역에 저장한다.

- 메소드의 호출과 함께 할당되며 메소드의 호출이 완료되면 소멸한다.

- 메소드의 호출정보를 스택 프레임(stack frame)이라고 한다.

- 푸시(push) 동작으로 데이터를 저장하고 팝(pop) 동작으로 데이터를 인출한다.

## 23) 1차원 배열
### 1차원 배열
#### [문법]
```java
1. 타입[] 배열명;     // 되도록 1번 사용
2. 타입 배열명[];
```
- 타입은 배열 요소로 저장되는 변수의 타입을 명시한다.
- 배열명은 배열이 선언된 후에 배열에 접근하기 위해 사용된다.

#### [문법]
```java
타입[] 배열명 = new 타입[배열길이];         // 배열의 선언과 생성을 동시에
```
- 자바에서는 이러한 배열도 모두 객체이므로 각각의 배열은 모두 자신만의 필드와 메소드를 가지고 있다.

#### [예제]
```java
int[] grade1 = new int[3]; // 길이가 3인 int형 배열의 선언 및 생성
int[] grade2 = new int[3]; // 길이가 3인 int형 배열의 선언 및 생성

grade1[0] = 85; // 인덱스를 이용한 배열의 초기화
grade1[1] = 65;
grade1[2] = 90;

grade2[0] = 85; // 배열의 길이보다 적은 수의 배열 요소만 초기화 -> 나머지 자동 초기화 (0)

for(int i = 0; i < grade1.length; i++) {
    System.out.print(grade1[i] + " "); // 인덱스를 이용한 배열로의 접근
}

for(int i = 0; i < grade2.length; i++) {
    System.out.print(grade2[i] + " "); // 인덱스를 이용한 배열로의 접근
}
```
- 위의 예제에서 사용한 ***length***는 배열의 길이를 저장하고 있는 배열 객체의 필드이다.

#### [실행 결과]
    85 65 90
    85 0 0

### 1차원 배열의 초기화
```java
1. 타입[] 배열이름 = {배열요소1, 배열요소2, ...};
2. 타입[] 배열이름 = new 타입[]{배열요소1, 배열요소2, ...};
```
- 초기화 블록에 맞춰 자동으로 배열의 길이 설정된다.
- 하지만, 다음과 같은 경우에는 2번째 방법만을 사용하여 초기화해야 한다.
    1. 배열의 선언과 초기화를 따로 진행해야 할 경우
    2. 메소드의 인수로 배열을 전달하면서 초기화해야 할 경우

#### [예제]
```java
int[] grade1 = {70, 90, 80};            // 배열의 선언과 동시에 초기화할 수 있음.
int[] grade2 = new int[]{70, 90, 80};   // 배열의 선언과 동시에 초기화할 수 있음.

int[] grade3;
grade3 = {70, 90, 80};                  // 이미 선언된 배열을 이 방법으로 초기화하면 오류가 발생함.

int[] grade4;
grade4 = new int[]{70, 90, 80};         // 이미 선언된 배열은 이 방법으로만 초기화할 수 있음.
```
위의 예제처럼 초기화 블록의 타입과 배열의 타입은 반드시 일치해야 한다.<br>

다음 예제는 앞선 예제와 같은 배열을 선언과 동시에 초기화 블록으로 초기화하는 예제이다.
#### [예제]
```java
int[] grade = new int[]{85, 65, 90};  // 길이가 3인 int형 배열을 선언과 동시에 초기화

for (int i = 0; i < grade.length; i++) {
    System.out.print(grade[i] + " "); // 인덱스를 이용한 배열로의 접근
}
```
#### [실행 결과]
    85 65 90

다음 예제는 배열 요소의 합과 평균을 구하는 예제이다.
#### [예제]
```java
int[] grade = new int[]{85, 65, 90}; // 길이가 3인 int형 배열을 선언과 동시에 초기화
int sum = 0;

for (int i = 0; i < grade.length; i++) {
    sum += grade[i];
}

System.out.println("모든 과목에서 받은 점수의 합은 " + sum + "입니다.");
System.out.println("이 학생의 평균은 " + (sum / grade.length) + "입니다.");
```
#### [실행 결과]
    모든 과목에서 받은 점수의 합은 240입니다.
    이 학생의 평균은 80입니다.

## 24) 다차원 배열
### 2차원 배열
- 배열의 요소로 1차원 배열을 가지는 배열이다.
- 자바에서는 2차원 배열을 나타내는 타입을 따로 제공하지 않는다.
- 대신에 1차원 배열의 배열요소로 또 다른 1차원 배열을 사용하여 2차원 배열을 나타낼 수 있다.<br>
#### [문법]
```java
1. 타입[][] 배열이름;
2. 타입 배열이름[][];
3. 타입[] 배열이름[];
```

![2차원 배열](https://www.tcpschool.com/lectures/img_java_array23.png)<br>

#### [예제]
```java
int[][] arr = new int[2][3];

int k = 10;
for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr[i].length; j++) {
        arr[i][j] = k; // 인덱스를 이용한 초기화
        k += 10;
    }
}

for (int i = 0; i < arr.length; i++) {
    for (int j = 0; j < arr[i].length; j++) {
        System.out.print(arr[i][j] + " ");
    }
    System.out.println();
}
```
#### [실행결과]
    10 20 30
    40 50 60
위의 예제에서 사용된 arr는 2차원 배열이며 arr[i]는 arr의 각 배열 요소로 1차원 배열이 된다.
- ***arr.length***는 2차원 배열인 arr의 배열 요소의 총 개수를 반환한다.
- ***arr[i].length***는 arr의 각 배열 요소인 1차원 배열이 가지고 있는 배열 요소의 총 개수를 반환한다.

### 2차원 배열의 초기화
#### [문법]
```java
타입 배열이름[행의길이][열의길이] = {
    {배열요소[0][0], 배열요소[0][1], ...},
    {배열요소[1][0], 배열요소[1][1], ...},
    {배열요소[2][0], 배열요소[2][1], ...},
    ...
};
```

### 가변 배열
    행마다 다른 길이의 배열을 저장할 수 있는 배열
자바에서는 2차원 배열을 생성할 때 열의 길이를 명시하지 않음으로써 행마다 다른 길이의 배열을 요소로 저장할 수 있다.

#### [예제]
```java
int[][] arr = new int[3][];

arr[0] = new int[2];
arr[1] = new int[4];
arr[2] = new int[1];
```
#### [예제]
```java
int[][] arr = {
    {10, 20},
    {10, 20, 30, 40},
    {10}
};
```

## 25) 배열의 활용
### 배열의 복사
자바에서 배열은 한 번 생성하면 그 길이를 변경할 수 없다.<br>
따라서, 더 많은 데이터를 저장하기 위해서는 더욱 큰 배열을 만들고 이전 배열의 데이터를 새로 만든 배열로 복사해야 한다.<br>

```
1. System 클래스의 arraycopy() 메소드
2. Arrays 클래스의 copyOf() 메소드
3. Object 클래스의 clone() 메소드
4. for문과 인덱스를 이용한 복사
```

이 중에서 가장 좋은 성능을 보이는 것은 배열의 복사만을 위해 만들어진 arraycopy() 메소드이다.<br>
하지만, 현재 배열의 복사를 위해 가장 많이 사용되는 메소드는 좀 더 유연한 방식의 copyOf() 메소드이다.

arraycopy(), copyOf() 메소드와 for 문을 이용한 복사는 배열의 길이를 마음대로 늘일 수 있다.<br>
하지만, clone() 메소드는 이전 배열과 같은 길이의 배열밖에 만들 수 없다.

#### [예제]
```java
int[] arr1 = new int[]{1, 2, 3, 4, 5};
int newLen = 10;

// 1. System 클래스의 arraycopy() 메소드
int[] arr2 = new int[newLen];
System.arraycopy(arr1, 0, arr2, 0, arr1.length);

// 2. Arrays 클래스의 copyOf() 메소드
int[] arr3 = Arrays.copyOf(arr1, 10);

// 3. Object 클래스의 clone() 메소드
int[] arr4 = (int[])arr1.clone();
 
// 4. for문과 인덱스를 이용한 복사
int[] arr5 = new int[newLen];
```

#### [실행 결과]
    1 2 3 4 5 0 0 0 0 0 
    1 2 3 4 5 0 0 0 0 0 
    1 2 3 4 5 
    1 2 3 4 5 0 0 0 0 0 

# 22/03/2024 (3week)
# 3. 연산자

# 15/03/2024 (2week)
# 2. 타입

## 7) 변수
### 변수(variable)
- 데이터를 저장할 수 있는 메모리 공간이다.
- 저장된 값은 변경될 수 있다.

### 변수의 종류
#### 1. 기본형(primitive type) 변수
    실제 연산에 사용되는 변수이며, 다음과 같이 8가지 종류의 기본형 변수를 제공하고 있다.
- 정수형 : byte, short, int, long
- 실수형 : float, double
- 문자형 : char
- 논리형 : boolean

#### 2. 참조형(reference type) 변수
    8개의 기본형 변수를 사용하여 사용자가 직접 만들어 사용하는 변수를 의미한다.

### 변수의 선언
- 자바에서 변수를 사용하기 전에 반드시 먼저 변수를 선언하고 초기화해야 한다.
- 반드시 해당 타입의 데이터만을 저장해야 한다.

#### 1. 변수의 선언만 하는 방법
##### [문법]
    타입 변수이름;
##### [예제]
```java
int num;                 // 변수의 선언
System.out.println(num); // 오류 발생
num = 20;                // 변수의 초기화
System.out.println(num); // 20
```
#### 2. 변수의 선언과 동시에 초기화하는 방법
##### [문법]
    1. 타입 변수이름[, 변수이름];
    2. 타입 변수이름 = 초깃값[, 변수이름 = 초깃값];
##### [예제]
```java
int num1, num2;                  // 같은 타입의 변수를 동시에 선언함.
double num3 = 3.14;              // 선언과 동시에 초기화함.
double num4 = 1.23, num5 = 4.56; // 같은 타입의 변수를 동시에 선언하면서 초기화함.
```
##### [잘못된 예제]
```java
double num1, num2;        // 같은 타입의 변수를 동시에 선언함.
num1 = 1.23, num2 = 4.56; // 하지만 이미 선언된 여러 변수를 동시에 초기화할 수는 없음.
```

## 8) 상수
### 상수(constant)
- 데이터를 정할 수 있는 메모리 공간이다.
- 변수와 다른 점은 프로그램이 실행되는 동안 메모리에 저장된 데이터를 변경할 수 없다.

### 상수의 선언
선언과 동시에 반드시 초기화해야 한다.
#### [예제]
```java
final int AGES = 30;
```
- 상수의 이름은 일반적으로 모두 대문자를 사용하여 선언한다.
- 여러 단어로 이루어진 이름의 경우에는 언더스코어(_)를 사용하여 구분한다.

### 리터럴(literal)
- 그 자체로 값을 의미한다.
- 즉, 변수와 상수와는 달리 데이터가 저장된 메모리 공간을 가리키는 이름을 가지고 있지 않다.
#### [예제]
```java
int var = 30;         // 30이 바로 리터럴임.
final int AGES = 100; // 100이 바로 리터럴임.
```

# 08/03/2024 (1week)
# 1. 자바 시작

## 2) 자바 기초
### 자바란?
- 자바는 C++과는 달리 처음부터 객체 지향 언어로 개발된 프로그래밍 언어이다.
- 자바는 자바 가상 머신(JVM)을 사용하여 어느 운영체제에서나 같은 형태로 실행될 수 있다.

### 자바의 역사
- 자바는 가전제품 내에서 동작하는 임베디드 프로그램을 위한 언어로써 마이크로시스템즈사의 제임스 고슬링 팀에 의해 개발되었다.
- 1991년에 오크(Oak)라는 이름으로 시작하여, 1996년에 발표된 1.0.2 버전부터 자바(Java)라는 이름을 사용하게 된다.
- 1998년 발표된 J2SE 1.2에서는 웹에서도 자바를 돌릴 수 있게 해 주는 자바 애플릿(Java Applet)이 추가되며, 자바의 인기는 급상승하게 된다.
- 2009년에 썬 마이크로시스템즈사가 오라클과 인수 합병됨에 따라 자바 또한 오라클로 소유권이 넘어간다.

### 자바의 특징
#### [장점]
    1. 운영체제와는 독립적으로 실행할 수 있다.
    2. 불필요한 기능을 과감히 제거하여 다른 언어에 비해 배우기 쉽다.
    3. 자동 메모리 관리 등을 지원하여 다른 언어에 비해 안정성이 높다.
    4. 연산자 오버로딩을 금지하고 제네릭을 도입함으로써 코드의 가독성을 높였다.
#### [단점]
    1. 실행하기 위해선 자바 가상 머신을 거쳐야 하므로, 다른 언어에 비해 실행 속도가 느리다.
    2. 예외 처리가 잘 되어 있지만, 개발자가 일일이 처리를 지정해 줘야 한다.
    3. 다른 언어에 비해 작성해야 하는 코드의 길이가 긴 편이다.

## 3) 자바 프로그래밍
### 자바 프로그램의 실행 과정
자바로 작성된 프로그램은 다음과 같은 순서로 실행된다.
![실행 과정](https://www.tcpschool.com/lectures/img_java_programming.png)<br>

### 자바 컴파일러 (Java compiler)
- 자바를 가지고 작성한 자바 소스 코드를 자바 가상 머신이 이해할 수 있는 **자바 바이트코드로 변환**한다.
- 자바를 설치하면 *javac.exe*라는 실행 파일 형태로 설치된다.

### 자바 바이트코드 (Java bytecode)
- 자바 가상 머신이 이해할 수 있는 언어로 변환된 자바 소스 코드를 의미한다.
- 자바 컴파일러에 의해 변환되는 코드의 명령어 크기가 1바이트라서 자바 바이트 코드라고 불린다.
- 확장자는 *.class*이다.
- 자바 가상 머신만 설치되어 있으면, 어떤 운영체제에서라도 실행될 수 있다.

### 자바 가상 머신(JVM, Java Virtual Machine)
- **자바 바이트코드를 실행**시키기 위한 **가상의 기계**라고 한다.
- 자바로 작성된 모든 프로그램은 **자바 가상 머신에서만 실행**될 수 있으므로, 자바 프로그램을 실행하기 위해서는 **반드시 자바 가상 머신이 설치**되어 있어야 한다.
- 오라클은 대부분의 주요 운영체제뿐만 아니라 웹 브라우저, 스마트폰, 가전기기 등에서도 **자바 가상 머신을 손쉽게 설치**할 수 있도록 지원한다.
![JVM](https://www.tcpschool.com/lectures/img_java_jvm.png)<br>
위 그림처럼 서로 다른 운영체제라도 자바 가상 머신만 설치되어 있다면, 같은 자바 프로그램이 아무런 추가 조치 없이 동작할 수 있다.<br>
따라서, 개발자는 한 번만 프로그램을 작성하면 모든 운영체제에서 같이 사용할 수 있는 장점이 있다.<br>
<br>
단, 자바 프로그램과는 달리 자바 가상 머신은 운영체제에 종속적이므로 각 운영체제에 맞는 자바 가상 머신을 설치해야 한다.<br>
또한, 자바 프로그램은 일반 프로그램보다 자바 가상 머신이라는 한 단계를 더 거쳐야 하므로 상대적으로 실행 속도가 느리다는 단점을 가지고 있다.

### 자바 가상 머신의 구성
#### 1. 자바 인터프리터(interpreter)
    자바 컴파일러에 의해 변환된 자바 바이트코드를 읽고 해석하는 역할이다.
#### 2. 클래스 로더(class loader)
    동적으로 클래스를 로딩해주는 역할이다.
#### 3. JIT컴파일러(Just-In-Time compiler)
    프로그램이 실행 중인 런타임에 실제 기계어로 변환해 주는 컴파일러이다.

    즉, 자바 컴파일러가 생성한 자바 바이트코드를 런타임에 바로 기계어로 변환하는데 사용한다.
#### 4. 가비지 컬렉터(garbage collector)
    더는 사용하지 않는 메모리를 자동으로 회수해 준다.

    따라서, 개발자가 따로 메모리를 관리하지 않아도 되므로 더욱 손쉽게 프로그래밍을 할 수 있도록 도와준다.

## 4) 자바 프로그램
### 간단한 자바 프로그램
- 1개 이상의 클래스로 구성된다.
- 클래스는 1개 이상의 필드(field)나 메소드(method)로 구성된다.

#### [원형]
```java
class 클래스이름 {

    필드의 선언

    필드의 선언

    ...

    메소드의 선언

    메소드의 선언

    ...

}
```
#### [예제]
```java
class Test {

    int field1;

    String field2;

 

    public void method1() {

        System.out.println("자바 프로그래밍!!");

    }

}
```
#### [실행결과]
    자바 프로그래밍!!

### main() 메소드
- 자바 프로그램이 실행되면 맨 먼저 main() 메소드를 찾아 그 안의 모든 명령문을 차례대로 실행한다.
- 따라서, 하나의 자바 프로그램에는 main() 메소드를 가지는 클래스가 반드시 하나는 존재해야 한다.

#### [원형]
```java
public static void main(String[] args) {

    ...

}
```
위의 원형처럼 main() 메소드는 반드시 ***public static void***로 선언되어야 한다.

자바 클래스 파일(*.java)에 public클래스가 존재하면 소스 파일의 이름은 반드시 해당 public클래스의 이름과 같아야 한다.<br>
이러한 public 클래스는 자바 클래스 파일마다 단 1개만 가질 수 있다.

### 명령문(statement)
자바의 모든 명령문의 반드시 세미콜론(;)으로 끝나야 한다.

### 주석(comment)
#### [문법]
```java
1. // 한 줄 주석

2. /* 여러

   줄

   주석 */

3. /* 여러 줄

     // 이렇게 두 줄 주석 안에 또 다른 한 줄 주석을 삽입할 수 있습니다.

주석입니다. */
```
여러 줄 주석은 중첩해서 사용하지 않는다.

## 5) System.out.println()
### 자바 표준 입출력 클래스
    1. System.in (입력)
    2. System.out (출력)
    3. System.err (출력)
- 사용자가 프로그램과 대화하기 위해서는 사용자와 프로그램 사이의 입출력을 담당하는 수단이 필요하다.
- 자바에서 모든 것이 객체로 표현되므로 입출력을 담당하는 수단 또한 모두 객체이다.

C언어의 printf() 함수나 scanf() 함수처럼 자바에서는 System이라는 표준 입출력 클래스를 정의하여 제공하고 있습니다.<br><br>
이러한 System 클래스는 java.lang 패키지에 포함되어 제공됩니다.<br><br>
System 클래스에는 표준 입출력을 위해 다음과 같은 클래스 변수(static variable)가 정의되어 있습니다.

### System.out.println()
#### [문법]
```java
System.out.println(출력할 데이터);
```

#### [예제]
```java
System.out.print(7);            // print() 메소드는 줄 바꿈 X
System.out.println(3);          // 정수 출력
System.out.println(3.14);       // 실수 출력
System.out.println("자바!");    // 문자열 출력
System.out.println("문자열끼리의 " + "연결도 가능합니다.");
System.out.println("숫자" + 3 + "과 문자열의 연결도 가능합니다.");
```

#### [실행 결과]
    73
    3.14
    자바!!
    문자열끼리의 연결도 가능합니다.
    숫자3과 문자열의 연결도 가능합니다.

println() 메소드와는 달리 print() 메소드는 전달된 데이터를 출력한 후에 줄 바꿈을 하지 않는다.

# README
```
# -> h1 태그
## -> h2 태그
### -> h3 태그
#### -> h4 태그
##### -> h5 태그
###### -> h6 태그


1. 첫 번째 순서 리스트
2. 두 번째 순서 리스트
3. 세 번째 순서 리스트(숫자가 틀려도 적용)

* 첫 번째 순서 없는 리스트
* 두 번째 순서 없는 리스트
- 첫번째 순서 없는 리스트(하이폰 사용)

*이탤릭체(스페이스 없이 사용)*

**볼드체(스페이스 없이 사용)**

스페이스를 두번 치면  
엔터 적용<br>
br태그도 적용 가능

```c++
#include <stdio.h>

int main()
{
    printf("Hello, world!\n");

    return 0;
}
```
